#!/usr/bin/python3

# TODO optparse handling and best commandline sys.exit practices
DEBUG = False
VERBOSE = False

import apt
import csv
import time
import datetime

from apt.utils import get_maintenance_end_date
from UpdateManager.Core.utils import twrap, get_dist

wrap_indented = lambda s: twrap(s, subsequent_indent="    ")


def check_expired(dist):
    release_date = get_release_date(dist)
    assert release_date
    # TODO: check if LTS in DISTRIB_DESCRIPTION, otherwise 9 months
    supported_for_n_month = 5 * 12 
    now = datetime.datetime.now()

    # mvo: we do not define the end date very precisely
    #      currently this is why it will just display a end
    #      range
    (support_end_year, support_end_month) = get_maintenance_end_date(release_date, supported_for_n_month)
    # check if the support has ended
    support_ended = (now.year > support_end_year or
                     (now.year == support_end_year and now.month > support_end_month))
    return support_ended, support_end_year, support_end_month


def get_release_date(dist):
    distro_data = '/usr/share/distro-info/ubuntu.csv'
    release_date = None
    try:
        with open(distro_data) as csvfile:
            csv_reader = csv.DictReader(csvfile)
            for row in csv_reader:
                if row['series'] == dist:
                    release_date = row['release']
                    break
    except FileNotFoundError:
        return None

    if not release_date:
        return None

    time_t = time.mktime(time.strptime(release_date, '%Y-%m-%d'))
    release_date = datetime.datetime.fromtimestamp(time_t)
    return release_date


class PatchStats:
    """Tracks overall patch status

    There are three important flags a package can have:

        1. If it comes from a repository which receives patches
        2. If it is actively receiving patches
        3. If it has ever been patched

    The Ubuntu main archive receives patches for 5 years.
    Canonical-owned archives (excluding partner) receive patches for 10 years.
        patches for 10 years.
    """
    def __init__(self):
        self.total_packages_covered = set()
        self.packages_expiring_5y = set()
        self.packages_covered_esm = set()
        self.packages_patched_main = set()
        self.packages_patched_esm = set()

        self.total_packages_uncovered = set()
        self.packages_uncovered_esm_universe = set()
        self.packages_uncovered_esm_main = set()
        # TODO no-update FIPS is never patched
        self.packages_uncovered_fips = set()


def print_debug(s):
    if DEBUG:
        print(s)


def trim_archive(archive):
    return archive.split("-")[-1]


def trim_site(host):
    # br.archive.ubuntu.com -> archive.ubuntu.com
    if host.endswith("archive.ubuntu.com"):
        return "archive.ubuntu.com"
    return host


def origins_for(ver: apt.package.Version) -> str:
    s=[]
    for origin in ver.origins:
        if not origin.site:
            # When the package is installed, site is empty, archive/component are "now/now"
            continue 
        site = trim_site(origin.site)
        s.append("%s %s/%s"% (site, origin.archive, origin.component))
    return ",".join(s)


if __name__ == "__main__":
    cache = apt.Cache()
    patchstats = PatchStats()
    distrib_codename = get_dist()
    is_release_expired, expiry_year, expiry_month = check_expired(distrib_codename)

    all_origins = set()
    origins_by_package = {}
    for pkg in cache:
        if not pkg.is_installed:
            continue
        pkgname = pkg.name

        pkg_sites = []

        origins_by_package[pkgname] = set()
        for ver in pkg.versions:
            # Loop through origins and store all of them. The idea here is that
            # we don't care where the installed package comes from, provided
            # there is at least one repository we identify as being
            # security-assured under either LTS or ESM.
            for origin in ver.origins:
                if not origin.site:
                    continue
                site = trim_site(origin.site)
                archive = origin.archive
                component = origin.component
                t = (site, archive, component)
                if not site:
                     continue
                all_origins.add(t)
                origins_by_package[pkgname].add(t)

            if DEBUG:
                pkg_sites.append("%s %s/%s"% (site, archive, component))

        print_debug("available versions for %s" % pkgname)
        print_debug(",".join(pkg_sites))

    # This tracks suites we care about. Sadly, it appears that the way apt
    # stores origins truncates away the path that comes after the
    # domainname in the site portion, or maybe I am just clueless, but
    # there's no way to tell FIPS apart from ESM, for instance.
    # See 00REPOS.txt for examples

    # TODO Need to handle:
    #   MAAS, lxd, juju PPAs
    #   other PPAs
    #   other repos

    # TODO handle restricted, multiverse
    suite_main = ("archive.ubuntu.com", distrib_codename, "main")
    suite_main_updates = ("archive.ubuntu.com", distrib_codename + "-updates", "main")
    suite_main_security = ("archive.ubuntu.com", distrib_codename + "-security", "main")
    suite_security = ("security.ubuntu.com", distrib_codename + "-security", "main")

    suite_universe = ("archive.ubuntu.com", distrib_codename, "universe")
    suite_universe_updates = ("archive.ubuntu.com", distrib_codename + "-updates", "universe")
    suite_esm_main = ("esm.ubuntu.com", "%s-infra-updates" % distrib_codename, "main")
    suite_esm_main_security = ("esm.ubuntu.com", "%s-infra-security" % distrib_codename, "main")
    suite_esm_universe = ("esm.ubuntu.com", "%s-apps-updates" % distrib_codename, "main")
    suite_esm_universe_security = ("esm.ubuntu.com", "%s-apps-security" % distrib_codename, "main")

    is_esm_main_enabled = (suite_esm_main in all_origins) or (suite_esm_main_security in all_origins)
    is_esm_universe_enabled = (suite_esm_universe in all_origins) or (suite_esm_universe_security in all_origins)

    # Now do the final loop through
    for pkg in cache:
        if not pkg.is_installed:
            continue
        pkgname = pkg.name
        pkg_origins = origins_by_package[pkgname]

        # This set of is_* booleans tracks specific situations we care about in
        # the logic below; for instance, if the package has a main origin, or
        # if the esm repos are enabled.

        # Some packages get added only in -updates, I'm looking at you
        # ubuntu-advantage-tools and libdrm-updates
        is_main_pkg_origin = (suite_main in pkg_origins) or (suite_main_updates in pkg_origins)
        is_universe_pkg_origin = (suite_universe in pkg_origins) or (suite_universe_updates in pkg_origins)

        # The below isn't technically true for packages that were added in -updates as per above
        is_main_pkg_patched = ((suite_main_updates in pkg_origins) or 
                            (suite_main_security in pkg_origins) or
                            (suite_security in pkg_origins))

        is_esm_main_pkg_origin = (suite_esm_main in pkg_origins) or (suite_esm_main_security in pkg_origins)
        is_esm_universe_pkg_origin = (suite_esm_universe in pkg_origins) or (suite_esm_universe_security in pkg_origins)

        # Prepare to go cross-eyed. This section basically holds all the
        # complex logic in deciding which buckets a package has to go into.
        # There is a lot of complexity that emerges from the simple variations
        # in archive and suite naming conventions; I've tried to make it as
        # legible as I can while jet-lagged but it's still hard. -- kiko

        if False: # TODO package has ESM fips origin
            # TODO package has ESM fips-updates origin: OK
            # If user has enabled FIPS, but not updates, BAD, but need some
            # thought on how to display it, as it can't be patched at all
            pass
        elif is_main_pkg_origin:
            if is_release_expired:
                if is_esm_main_enabled:
                    patchstats.total_packages_covered.add(pkgname)
                    patchstats.packages_covered_esm.add(pkgname)
                    if is_esm_main_pkg_origin:
                        patchstats.packages_patched_esm.add(pkgname)
                else:
                    patchstats.total_packages_uncovered.add(pkgname)
                    patchstats.packages_uncovered_esm_main.add(pkgname)
                    if is_main_pkg_patched:
                        patchstats.packages_patched_main.add(pkgname)
            else:
                patchstats.total_packages_covered.add(pkgname)
                if not is_esm_main_enabled:
                    # If the release isn't expired, but there is no ESM, warn
                    # users they don't have 10 years
                    patchstats.packages_expiring_5y.add(pkgname)
                if is_main_pkg_patched:
                    patchstats.packages_patched_main.add(pkgname)
        elif is_universe_pkg_origin:
            if is_esm_universe_enabled:
                patchstats.total_packages_covered.add(pkgname)
                patchstats.packages_covered_esm.add(pkgname)
                if is_esm_universe_pkg_origin:
                    patchstats.packages_patched_esm.add(pkgname)
            else:
                patchstats.total_packages_uncovered.add(pkgname)
                patchstats.packages_uncovered_esm_universe.add(pkgname)
        else:
            patchstats.total_packages_uncovered.add(pkgname)

    # Outcomes we care about are:
    #   Packages covered
    #       Of which M expire in Y years (i.e. Main packages exist, not expired)
    #       Of which N covered by ESM (i.e. Universe packages exist, apps-security)
    #       Packages updated
    #           Of which P have received free updates
    #           Of which Q have received ESM updates
    #   Packages uncovered
    #       Of which R would be covered under ESM U (Universe packages exist, no apps-security)
    #       Of which S would be covered under ESM I (Main packages exist, 5y expired, no apps-security)

    total_packages = len(patchstats.total_packages_covered) + len(patchstats.total_packages_uncovered)
    print("Total packages: %d" % total_packages)
    if patchstats.total_packages_covered:
        print("    - Security assured: %d" % len(patchstats.total_packages_covered))
    if patchstats.packages_patched_main:
        print("        Patched via LTS: %d" % len(patchstats.packages_patched_main))
    if patchstats.packages_patched_esm:
        print("        Patched via ESM Assurance: %d" % len(patchstats.packages_patched_esm))
    if patchstats.packages_expiring_5y:
        print("        ** Expiring on %d/%d: %d" %
             (expiry_month, expiry_year, len(patchstats.packages_expiring_5y)))
    # TODO Would be nice to say "Assured through %d/%d" here for ESM
    if patchstats.total_packages_uncovered:
        print("    - No assurance: %d" % len(patchstats.total_packages_uncovered))
    if patchstats.packages_uncovered_esm_universe:
        print("        ** ESM Assurance (Universe) available for: %d" % len(patchstats.packages_uncovered_esm_universe))
    if patchstats.packages_uncovered_esm_main:
        print("        ** ESM Assurance (Main) available for: %d" % len(patchstats.packages_uncovered_esm_main))

    if VERBOSE:
        if patchstats.packages_uncovered_esm_main:
            print("\nCoverable via Security Assurance (Main):\n    %s"
                 % wrap_indented(" ".join(patchstats.packages_uncovered_esm_main)))
        if patchstats.packages_uncovered_esm_universe:
            print("\nCoverable via Security Assurance (Universe):\n    %s"
                 % wrap_indented(" ".join(patchstats.packages_uncovered_esm_universe)))
        not_coverable = (patchstats.total_packages_uncovered - 
                         patchstats.packages_uncovered_esm_universe -
                         patchstats.packages_uncovered_esm_main)
        if not_coverable:
            print("\nNot coverable:\n    %s" % wrap_indented(" ".join(not_coverable)))

        print("Package sources:")
        for site, archive, component in sorted(all_origins):
            print("    - %-20s %-25s %s" % (site, archive, component))

    
